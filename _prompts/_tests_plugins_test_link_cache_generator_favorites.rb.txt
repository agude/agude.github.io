You are a Senior Ruby Engineer specializing in Jekyll. I need you to fix RuboCop static analysis errors in the following file.

FILE: _tests/plugins/test_link_cache_generator_favorites.rb
CONTEXT: This is a Minitest file. Documentation should briefly explain what is being tested. Do not over-engineer refactoring in tests; prefer readability.

THE ERRORS TO FIX:
- Line 6: [Style/Documentation] Missing top-level documentation comment for `class TestLinkCacheGeneratorFavorites`.


--------------------------------------------------
STYLE GUIDE & INSTRUCTIONS:

1. **Documentation (Style/Documentation):**
   - **Requirement:** Every Class and Module must have a top-level comment block.
   - **Format:**
     ```ruby
     # Short summary of what this class does.
     #
     # (Optional) Detailed explanation or Liquid usage example:
     # {% my_tag param="value" %}
     class MyClass ...
     ```
   - **Quality:** Do not write "Class for X". Write "Generates X based on Y configuration."

2. **Frozen String Literals:**
   - Ensure `# frozen_string_literal: true` is the **very first line** of the file.

3. **Naming & Variables:**
   - Fix short variable names (e.g., change `l` to `logger`, `p` to `path`).
   - Use snake_case for variables and methods.

4. **Refactoring Strategy (Only if Metrics/* errors exist):**
   - **If** the error is `Metrics/MethodLength` or `Complexity`:
     - Extract logic into private helper methods (e.g., `def _helper_method`).
     - Or, extract a private helper class if state management is complex.
   - **If** there are NO metrics errors, **DO NOT** refactor the logic structure. Just fix the style/docs.

5. **Safety:**
   - **CRITICAL:** Do not change the external behavior or API of the code.
   - Do not remove existing comments unless they are the specific "rubocop:disable" comments causing issues.

--------------------------------------------------
SOURCE CODE:
```ruby
# frozen_string_literal: true

# _tests/plugins/test_link_cache_generator_favorites.rb
require_relative '../test_helper'

class TestLinkCacheGeneratorFavorites < Minitest::Test
  def setup
    # --- Mock Books (Targets of the links) ---
    @book_a = create_doc({ 'title' => 'Book A' }, '/books/a.html')
    @book_b = create_doc({ 'title' => 'Book B' }, '/books/b.html')
    @book_c = create_doc({ 'title' => 'Book C' }, '/books/c.html')

    # --- Mock Posts (Sources of the links) ---
    # A favorites post linking to Book B via card, but Book A via link (which should be ignored)
    @favorites_post_2023 = create_doc(
      { 'title' => 'Favorites 2023', 'is_favorites_list' => 2023 },
      '/posts/fav23.html',
      '{% book_link "Book A" %} and {% book_card_lookup title="Book B" %}'
    )

    # Another favorites post linking to one existing and one non-existent book via card
    @favorites_post_2024 = create_doc(
      { 'title' => 'Favorites 2024', 'is_favorites_list' => 2024 },
      '/posts/fav24.html',
      '{% book_card_lookup title="Book B" %} and {% book_card_lookup title="Non-Existent Book" %}'
    )

    # A regular post that should be ignored, even with a book_card_lookup
    @regular_post_with_card = create_doc(
      { 'title' => 'Regular Post' },
      '/posts/regular.html',
      '{% book_card_lookup title="Book C" %}'
    )

    # The create_site helper runs the LinkCacheGenerator automatically
    @site = create_site(
      {},
      { 'books' => [@book_a, @book_b, @book_c] },
      [],
      [@favorites_post_2023, @favorites_post_2024, @regular_post_with_card]
    )
    @favorites_cache = @site.data['link_cache']['favorites_mentions']
    @favorites_posts_to_books_cache = @site.data['link_cache']['favorites_posts_to_books']
  end

  def test_favorites_mentions_cache_is_created
    refute_nil @favorites_cache, "The 'favorites_mentions' cache should exist"
  end

  def test_ignores_book_link_mentions_from_favorites_post
    # Book A is mentioned in fav23.html via {% book_link %}, which should be ignored.
    mentions_for_a = @favorites_cache[@book_a.url]
    assert_nil mentions_for_a, 'Book A should NOT be in the favorites cache as it was linked via book_link'
  end

  def test_ignores_mentions_from_regular_posts
    # Book C is mentioned in a regular post via book_card_lookup, but should be ignored
    # because the post is not a favorites list.
    assert_nil @favorites_cache[@book_c.url], 'Book C, mentioned in a regular post, should not be in the cache'
  end

  def test_book_mentioned_in_multiple_lists_is_tracked_correctly
    # Book B is mentioned via book_card_lookup in both favorites posts.
    mentions_for_b = @favorites_cache[@book_b.url]
    refute_nil mentions_for_b, 'Book B should be in the favorites cache'
    assert_equal 2, mentions_for_b.size, 'Book B should be mentioned by two posts'

    mentioning_post_urls = mentions_for_b.map(&:url).sort
    expected_urls = [@favorites_post_2023.url, @favorites_post_2024.url].sort
    assert_equal expected_urls, mentioning_post_urls
  end

  def test_ignores_links_to_non_existent_books
    # The cache should only contain keys for books that actually exist.
    # Only Book B is mentioned via book_card_lookup.
    assert_equal 1, @favorites_cache.keys.size
    assert_includes @favorites_cache.keys, @book_b.url
    refute_includes @favorites_cache.keys, @book_a.url
  end

  def test_handles_no_favorites_posts_gracefully
    site_no_favs = create_site(
      {},
      { 'books' => [@book_a, @book_c] },
      [],
      [@regular_post_with_card] # Only a regular post
    )
    cache = site_no_favs.data['link_cache']['favorites_mentions']
    assert_empty cache, 'Favorites cache should be empty if no posts are flagged'
  end

  def test_handles_favorites_post_with_no_links
    favorites_post_no_links = create_doc(
      { 'title' => 'Favorites No Links', 'is_favorites_list' => 2025 },
      '/posts/fav25.html',
      'This post has no book links.'
    )
    site_with_empty_fav = create_site(
      {},
      { 'books' => [@book_a, @book_b] },
      [],
      [favorites_post_no_links, @favorites_post_2023]
    )
    cache = site_with_empty_fav.data['link_cache']['favorites_mentions']
    # The cache should still contain Book B from the 2023 post, but nothing new.
    assert_equal 1, cache.keys.size
    assert_includes cache.keys, @book_b.url
  end

  def test_book_mentioned_multiple_times_in_one_post_is_added_once
    favorites_post_multi_mention = create_doc(
      { 'title' => 'Favorites Multi-Mention', 'is_favorites_list' => 2026 },
      '/posts/fav26.html',
      '{% book_card_lookup title="Book A" %} and again {% book_card_lookup title="Book A" %}'
    )
    site_with_multi_mention = create_site(
      {},
      { 'books' => [@book_a] },
      [],
      [favorites_post_multi_mention]
    )
    cache = site_with_multi_mention.data['link_cache']['favorites_mentions']
    mentions_for_a = cache[@book_a.url]
    refute_nil mentions_for_a
    assert_equal 1, mentions_for_a.size,
                 'Book A should only be listed once for the post that mentions it multiple times'
    assert_equal favorites_post_multi_mention.url, mentions_for_a.first.url
  end

  def test_inverted_favorites_cache_is_created_correctly
    refute_nil @favorites_posts_to_books_cache, "The 'favorites_posts_to_books' cache should exist"
    assert_equal 2, @favorites_posts_to_books_cache.keys.size, 'Should have entries for two favorites posts'

    # Check 2023 post (mentions Book B via card)
    books_for_2023 = @favorites_posts_to_books_cache[@favorites_post_2023.url]
    refute_nil books_for_2023
    assert_equal 1, books_for_2023.size
    assert_equal @book_b.url, books_for_2023.first.url

    # Check 2024 post (mentions Book B via card)
    books_for_2024 = @favorites_posts_to_books_cache[@favorites_post_2024.url]
    refute_nil books_for_2024
    assert_equal 1, books_for_2024.size # Mentions one valid book
    assert_equal @book_b.url, books_for_2024.first.url

    # Check that regular post is not a key
    refute @favorites_posts_to_books_cache.key?(@regular_post_with_card.url)
  end
end
```

**OUTPUT:**
Return ONLY the full, valid Ruby code for the file. No markdown wrappers, no conversational filler.
