You are a Senior Ruby Engineer specializing in Jekyll. I need you to fix RuboCop static analysis errors in the following file.

FILE: _tests/plugins/utils/book_list_utils/test_favorites_lists_display.rb
CONTEXT: This is a Minitest file. Documentation should briefly explain what is being tested. Do not over-engineer refactoring in tests; prefer readability.

THE ERRORS TO FIX:
- Line 6: [Style/Documentation] Missing top-level documentation comment for `class TestBookListUtilsFavoritesListsDisplay`.


--------------------------------------------------
STYLE GUIDE & INSTRUCTIONS:

1. **Documentation (Style/Documentation):**
   - **Requirement:** Every Class and Module must have a top-level comment block.
   - **Format:**
     ```ruby
     # Short summary of what this class does.
     #
     # (Optional) Detailed explanation or Liquid usage example:
     # {% my_tag param="value" %}
     class MyClass ...
     ```
   - **Quality:** Do not write "Class for X". Write "Generates X based on Y configuration."

2. **Frozen String Literals:**
   - Ensure `# frozen_string_literal: true` is the **very first line** of the file.

3. **Naming & Variables:**
   - Fix short variable names (e.g., change `l` to `logger`, `p` to `path`).
   - Use snake_case for variables and methods.

4. **Refactoring Strategy (Only if Metrics/* errors exist):**
   - **If** the error is `Metrics/MethodLength` or `Complexity`:
     - Extract logic into private helper methods (e.g., `def _helper_method`).
     - Or, extract a private helper class if state management is complex.
   - **If** there are NO metrics errors, **DO NOT** refactor the logic structure. Just fix the style/docs.

5. **Safety:**
   - **CRITICAL:** Do not change the external behavior or API of the code.
   - Do not remove existing comments unless they are the specific "rubocop:disable" comments causing issues.

--------------------------------------------------
SOURCE CODE:
```ruby
# frozen_string_literal: true

# _tests/plugins/utils/book_list_utils/test_favorites_lists_display.rb
require_relative '../../../test_helper'

class TestBookListUtilsFavoritesListsDisplay < Minitest::Test
  def setup
    setup_test_documents
    setup_site_and_context
    setup_silent_logger
  end

  def get_favorites_data(site = @site, context = @context)
    Jekyll.stub :logger, @silent_logger_stub do
      BookListUtils.get_data_for_favorites_lists(site: site, context: context)
    end
  end

  private

  def setup_test_documents
    # --- Mock Books ---
    @book_a = create_doc({ 'title' => 'Apple Book' }, '/books/a.html')
    @book_b = create_doc({ 'title' => 'Banana Book' }, '/books/b.html')
    @book_z = create_doc({ 'title' => 'Zebra Book' }, '/books/z.html')

    # --- Mock Posts ---
    @fav_post_2024 = create_doc(
      { 'title' => 'Favorites 2024', 'is_favorites_list' => 2024 },
      '/posts/fav24.html'
    )
    @fav_post_2023 = create_doc(
      { 'title' => 'Favorites 2023', 'is_favorites_list' => 2023 },
      '/posts/fav23.html'
    )
    @regular_post = create_doc({ 'title' => 'Regular Post' }, '/posts/regular.html')
  end

  def setup_site_and_context
    # --- Site & Context ---
    @site = create_site(
      {},
      { 'books' => [@book_a, @book_b, @book_z] },
      [],
      [@fav_post_2023, @fav_post_2024, @regular_post]
    )
    # Manually set up the cache that the util will read from
    @site.data['link_cache']['favorites_posts_to_books'] = {
      @fav_post_2024.url => [@book_z, @book_a], # Intentionally unsorted books
      @fav_post_2023.url => [@book_b]
    }
    current_page = create_doc({ 'path' => 'current.html' }, '/current.html')
    @context = create_context({}, { site: @site, page: current_page })
  end

  def setup_silent_logger
    @silent_logger_stub = Object.new.tap do |logger|
      def logger.warn(param, msg); end

      def logger.error(param, msg); end

      def logger.info(param, msg); end

      def logger.debug(param, msg); end
    end
  end

  def test_get_data_for_favorites_lists_correct_structure_and_sorting
    data = get_favorites_data

    assert_empty data[:log_messages].to_s
    assert_equal 2, data[:favorites_lists].size, 'Should find two favorites lists'

    assert_correct_list_order(data)
    assert_correct_2024_list_content(data[:favorites_lists][0])
    assert_correct_2023_list_content(data[:favorites_lists][1])
  end

  def test_get_data_for_favorites_lists_no_favorites_posts_logs_info
    site_no_favs = create_site({}, { 'books' => [@book_a] }, [], [@regular_post])
    site_no_favs.config['plugin_logging']['BOOK_LIST_FAVORITES'] = true
    context_no_favs = create_context({}, { site: site_no_favs, page: @context.registers[:page] })

    data = get_favorites_data(site_no_favs, context_no_favs)
    assert_empty data[:favorites_lists]
    expected_info = /<!-- \[INFO\] BOOK_LIST_FAVORITES_FAILURE: Reason='No posts with /
    assert_match(expected_info, data[:log_messages])
  end

  def test_get_data_for_favorites_lists_prerequisites_missing_logs_error
    site_no_cache = create_site({}, {}, [], [@fav_post_2023])
    site_no_cache.data['link_cache'].delete('favorites_posts_to_books')
    site_no_cache.config['plugin_logging']['BOOK_LIST_FAVORITES'] = true
    context_no_cache = create_context({}, { site: site_no_cache, page: @context.registers[:page] })

    data = get_favorites_data(site_no_cache, context_no_cache)
    assert_empty data[:favorites_lists]
    expected_error = /<!-- \[ERROR\] BOOK_LIST_FAVORITES_FAILURE: Reason='Prerequisites missing: /
    assert_match(expected_error, data[:log_messages])
  end

  def assert_correct_list_order(data)
    # Overall list order (by year descending)
    assert_equal @fav_post_2024.url, data[:favorites_lists][0][:post].url
    assert_equal @fav_post_2023.url, data[:favorites_lists][1][:post].url
  end

  def assert_correct_2024_list_content(list_2024)
    assert_equal 2, list_2024[:books].size
    # Books should be sorted alphabetically by title
    assert_equal @book_a.data['title'], list_2024[:books][0].data['title']
    assert_equal @book_z.data['title'], list_2024[:books][1].data['title']
  end

  def assert_correct_2023_list_content(list_2023)
    assert_equal 1, list_2023[:books].size
    assert_equal @book_b.data['title'], list_2023[:books][0].data['title']
  end
end
```

**OUTPUT:**
Return ONLY the full, valid Ruby code for the file. No markdown wrappers, no conversational filler.
