I need you to refactor the following Ruby file to fix RuboCop static analysis errors and improve general code quality.

FILE: _plugins/utils/backlink_utils.rb

THE ERRORS TO FIX:
- Line 17: [Metrics/AbcSize] Assignment Branch Condition size for `find_book_backlinks` is too high. [<9, 28, 14> 32.57/17]
- Line 17: [Metrics/CyclomaticComplexity] Cyclomatic complexity for `find_book_backlinks` is too high. [15/7]
- Line 17: [Metrics/MethodLength] Method has too many lines. [22/10]
- Line 17: [Metrics/PerceivedComplexity] Perceived complexity for `find_book_backlinks` is too high. [15/8]
- Line 19: [Layout/LineLength] Line is too long. [121/120]


STYLE GUIDE & REFACTORING PATTERNS:
1. **Complex Logic Extraction (Tags/Classes):**
   - If a method (like `render`) is too complex, extract the logic into a private helper class defined within the same module/class.
   - **Pattern:**
     ```ruby
     def render(context)
       MyTagRenderer.new(context).render
     end

     # Helper class to handle rendering logic
     class MyTagRenderer
       def initialize(context)
         @context = context
         @site = context.registers[:site]
       end

       def render
         # logic here
       end
     end
     ```

2. **Stateless Utilities (Modules):**
   - For utility modules, keep methods static (`def self.method`).
   - Break complex logic into private class methods named with a leading underscore.
   - **Pattern:**
     ```ruby
     def self.public_method(arg)
       _private_helper(arg)
     end

     def self._private_helper(arg)
       # logic
     end
     ```

3. **General Quality:**
   - Fix "bad code" or poor style even if RuboCop misses it (e.g., redundant logic, unclear variable names, deeply nested conditionals).
   - Ensure `# frozen_string_literal: true` is at the top.

INSTRUCTIONS:
1. Fix the specific RuboCop errors listed above.
2. Apply the Refactoring Patterns defined in the Style Guide.
3. Improve readability and maintainability generally.
4. **CRITICAL:** DO NOT change the external behavior or API of the code.
5. DO NOT remove comments unless they are the specific "rubocop:disable" comments causing issues.
6. Return the FULL content of the fixed file.

SOURCE CODE:
```ruby
# frozen_string_literal: true

# _plugins/utils/backlink_utils.rb
require 'jekyll'
require 'cgi'
require_relative 'plugin_logger_utils'
require_relative 'text_processing_utils'

module BacklinkUtils
  # Finds books in the 'books' collection that link back to the current_page.
  # Returns a list of [canonical_title, url] pairs, sorted alphabetically by title (ignoring articles).
  #
  # @param current_page [MockDocument, Jekyll::Page, Jekyll::Document] The page to find backlinks for.
  # @param site [MockSite, Jekyll::Site] The Jekyll site object.
  # @param context [Liquid::Context] The current Liquid context (needed for logging).
  # @return [Array<Array(String, String)>] A sorted list of [canonical_title, url] pairs.
  def self.find_book_backlinks(current_page, site, context)
    # --- Basic Sanity Checks ---
    unless site && current_page && site.data['link_cache'] && site.data['link_cache']['backlinks'] && current_page['url']
      PluginLoggerUtils.log_liquid_failure(
        context: context,
        tag_type: 'BACKLINK_UTIL',
        reason: 'Prerequisites missing: site, page, link_cache, or backlinks cache unavailable.',
        identifiers: { PageURL: current_page ? (current_page['url'] || 'N/A') : 'N/A' },
        level: :error
      )
      return [] # Return empty list if prerequisites fail
    end
    # --- End Sanity Checks ---

    current_url = current_page['url']
    backlinks_cache = site.data['link_cache']['backlinks']

    # --- Retrieve Backlinks from Cache ---
    backlinking_docs = backlinks_cache[current_url] || []

    # --- Sort and Return Title/URL Pairs ---
    return [] if backlinking_docs.empty?

    # Map to [sort_key, canonical_title, url] triplets for sorting
    backlinks_data = backlinking_docs.map do |book_doc|
      title = book_doc.data['title']
      next if title.nil? || title.strip.empty? # Skip if backlinking doc has no title

      sort_key = TextProcessingUtils.normalize_title(title, strip_articles: true)
      [sort_key, title, book_doc.url]
    end.compact # Remove any nils from skipped items

    # Sort by sort_key, then map to [canonical_title, url] pairs
    backlinks_data.sort_by { |triplet| triplet[0] }
                  .map { |triplet| [triplet[1], triplet[2]] } # Map to [title, url]
  end
end
```
