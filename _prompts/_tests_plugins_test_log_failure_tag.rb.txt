I need you to refactor the following Ruby file to fix RuboCop static analysis errors and improve general code quality.

FILE: _tests/plugins/test_log_failure_tag.rb

THE ERRORS TO FIX:
- Line 7: [Metrics/ClassLength] Class has too many lines. [136/100]
- Line 8: [Metrics/MethodLength] Method has too many lines. [11/10]
- Line 54: [Metrics/AbcSize] Assignment Branch Condition size for `test_render_basic_type_and_reason_delegates_correctly` is too high. [<9, 15, 0> 17.49/17]
- Line 54: [Metrics/MethodLength] Method has too many lines. [19/10]
- Line 78: [Metrics/MethodLength] Method has too many lines. [17/10]
- Line 102: [Metrics/MethodLength] Method has too many lines. [17/10]
- Line 125: [Metrics/MethodLength] Method has too many lines. [16/10]
- Line 147: [Metrics/MethodLength] Method has too many lines. [14/10]


STYLE GUIDE & REFACTORING PATTERNS:
1. **Complex Logic Extraction (Tags/Classes):**
   - If a method (like `render`) is too complex, extract the logic into a private helper class defined within the same module/class.
   - **Pattern:**
     ```ruby
     def render(context)
       MyTagRenderer.new(context).render
     end

     # Helper class to handle rendering logic
     class MyTagRenderer
       def initialize(context)
         @context = context
         @site = context.registers[:site]
       end

       def render
         # logic here
       end
     end
     ```

2. **Stateless Utilities (Modules):**
   - For utility modules, keep methods static (`def self.method`).
   - Break complex logic into private class methods named with a leading underscore.
   - **Pattern:**
     ```ruby
     def self.public_method(arg)
       _private_helper(arg)
     end

     def self._private_helper(arg)
       # logic
     end
     ```

3. **General Quality:**
   - Fix "bad code" or poor style even if RuboCop misses it (e.g., redundant logic, unclear variable names, deeply nested conditionals).
   - Ensure `# frozen_string_literal: true` is at the top.

INSTRUCTIONS:
1. Fix the specific RuboCop errors listed above.
2. Apply the Refactoring Patterns defined in the Style Guide.
3. Improve readability and maintainability generally.
4. **CRITICAL:** DO NOT change the external behavior or API of the code.
5. DO NOT remove comments unless they are the specific "rubocop:disable" comments causing issues.
6. Return the FULL content of the fixed file.

SOURCE CODE:
```ruby
# frozen_string_literal: true

# _tests/plugins/test_log_failure_tag.rb
require_relative '../test_helper'
require_relative '../../_plugins/log_failure_tag' # Load the tag

class TestLogFailureTag < Minitest::Test
  def setup
    @site = create_site
    @context = create_context(
      {
        'page_path_var' => 'path/from/variable.html',
        'user_id_var' => 12_345,
        'status_var' => 'pending'
      },
      { site: @site, page: create_doc({ 'path' => 'current_test_page.html' }, '/current.html') }
    )
    @site.config['plugin_logging']['MY_CUSTOM_ERROR'] = true
    @site.config['plugin_logging']['TEMPLATE_INFO'] = true
  end

  def render_tag(markup_inside_tag, context = @context)
    Liquid::Template.parse("{% log_failure #{markup_inside_tag} %}").render!(context)
  end

  # --- Tests for initialize (Syntax Errors) ---

  def test_syntax_error_missing_type_argument
    markup = "reason='Something happened'"
    err = assert_raises Liquid::SyntaxError do
      Liquid::Template.parse("{% log_failure #{markup} %}")
    end
    assert_match "Required argument 'type' is missing", err.message
  end

  def test_syntax_error_missing_reason_argument
    markup = "type='MY_ERROR'"
    err = assert_raises Liquid::SyntaxError do
      Liquid::Template.parse("{% log_failure #{markup} %}")
    end
    assert_match "Required argument 'reason' is missing", err.message
  end

  def test_syntax_error_invalid_arguments_near
    markup = "type='T' reason='R' this_is_not_key_value"
    err = assert_raises Liquid::SyntaxError do
      Liquid::Template.parse("{% log_failure #{markup} %}")
    end
    assert_match "Invalid arguments near 'this_is_not_key_value'", err.message
  end

  # --- Tests for render (Argument Resolution and Delegation) ---

  def test_render_basic_type_and_reason_delegates_correctly
    markup = "type='MY_CUSTOM_ERROR' reason='A basic failure occurred.'"
    expected_log_type = 'MY_CUSTOM_ERROR'
    expected_reason = 'A basic failure occurred.'
    expected_identifiers = {}
    mock_return_value = '<!-- MY_CUSTOM_ERROR LOGGED -->'

    captured_args = nil
    PluginLoggerUtils.stub :log_liquid_failure, lambda { |args|
      captured_args = args
      mock_return_value
    } do
      output = render_tag(markup)
      assert_equal mock_return_value, output
    end

    refute_nil captured_args, 'PluginLoggerUtils.log_liquid_failure should have been called'
    assert_equal @context, captured_args[:context]
    assert_equal expected_log_type, captured_args[:tag_type]
    assert_equal expected_reason, captured_args[:reason]
    assert_equal expected_identifiers, captured_args[:identifiers]
    assert_nil captured_args[:level], 'Level should be nil to use default, or explicitly :warn'
  end

  def test_render_with_literal_identifiers
    # Removed unused variables, using markup_corrected and expected_identifiers_corrected directly
    markup_corrected = "type='MY_CUSTOM_ERROR' reason='Failure with details.' id='item123' status='failed' count='5'"
    expected_identifiers_corrected = {
      'id' => 'item123',
      'status' => 'failed',
      'count' => '5' # LiquidUtils.resolve_value for "'5'" returns string "5"
    }

    mock_return_value = '<!-- LOGGED WITH LITERALS -->'
    captured_args = nil
    PluginLoggerUtils.stub :log_liquid_failure, lambda { |args|
      captured_args = args
      mock_return_value
    } do
      output = render_tag(markup_corrected)
      assert_equal mock_return_value, output
    end

    refute_nil captured_args
    # Assertion will now expect original casing due to fix in LogFailureTag
    assert_equal expected_identifiers_corrected, captured_args[:identifiers]
  end

  def test_render_with_variable_identifiers
    markup = "type='TEMPLATE_INFO' reason='User action.' path=page_path_var user=user_id_var current_status=status_var"
    expected_identifiers = {
      'path' => 'path/from/variable.html',
      'user' => 12_345,
      'current_status' => 'pending'
    }
    mock_return_value = '<!-- LOGGED WITH VARIABLES -->'

    captured_args = nil
    PluginLoggerUtils.stub :log_liquid_failure, lambda { |args|
      captured_args = args
      mock_return_value
    } do
      output = render_tag(markup)
      assert_equal mock_return_value, output
    end

    refute_nil captured_args
    # Assertion will now expect original casing
    assert_equal expected_identifiers, captured_args[:identifiers]
  end

  def test_render_with_mixed_literal_and_variable_identifiers
    markup = "type='MY_CUSTOM_ERROR' reason='Mixed event' literal_id='abc' var_id=user_id_var"
    expected_identifiers = {
      'literal_id' => 'abc',
      'var_id' => 12_345
    }
    mock_return_value = '<!-- LOGGED MIXED -->'

    captured_args = nil
    PluginLoggerUtils.stub :log_liquid_failure, lambda { |args|
      captured_args = args
      mock_return_value
    } do
      output = render_tag(markup)
      assert_equal mock_return_value, output
    end

    refute_nil captured_args
    # Assertion will now expect original casing
    assert_equal expected_identifiers, captured_args[:identifiers]
  end

  def test_render_identifier_key_capitalization_is_preserved_by_tag
    markup = "type='T' reason='R' myKey='val' another_Key='val2'"
    expected_identifiers_passed_to_util = {
      'myKey' => 'val',
      'another_Key' => 'val2'
    }
    mock_return_value = '<!-- KEY TEST -->'
    captured_args = nil
    PluginLoggerUtils.stub :log_liquid_failure, lambda { |args|
      captured_args = args
      mock_return_value
    } do
      render_tag(markup)
    end
    # Assertion will now expect original casing
    assert_equal expected_identifiers_passed_to_util, captured_args[:identifiers]
  end

  def test_render_handles_empty_markup_gracefully_but_fails_syntax
    err = assert_raises Liquid::SyntaxError do
      Liquid::Template.parse('{% log_failure %}')
    end
    assert_match "Required argument 'type' is missing", err.message
  end
end
```
