I need you to refactor the following Ruby file to fix RuboCop static analysis errors and improve general code quality.

FILE: _tests/plugins/utils/test_plugin_logger_utils.rb

THE ERRORS TO FIX:
- Line 1: [Style/FrozenStringLiteralComment] Missing frozen string literal comment.
- Line 5: [Metrics/ClassLength] Class has too many lines. [171/100]
- Line 31: [Metrics/MethodLength] Method has too many lines. [11/10]
- Line 51: [Metrics/MethodLength] Method has too many lines. [13/10]
- Line 74: [Metrics/MethodLength] Method has too many lines. [12/10]
- Line 101: [Layout/LineLength] Line is too long. [175/120]
- Line 114: [Metrics/MethodLength] Method has too many lines. [11/10]
- Line 134: [Metrics/MethodLength] Method has too many lines. [14/10]
- Line 156: [Metrics/MethodLength] Method has too many lines. [13/10]
- Line 177: [Metrics/MethodLength] Method has too many lines. [14/10]
- Line 213: [Metrics/MethodLength] Method has too many lines. [12/10]
- Line 240: [Layout/LineLength] Line is too long. [156/120]
- Line 252: [Layout/LineLength] Line is too long. [160/120]


STYLE GUIDE & REFACTORING PATTERNS:
1. **Complex Logic Extraction (Tags/Classes):**
   - If a method (like `render`) is too complex, extract the logic into a private helper class defined within the same module/class.
   - **Pattern:**
     ```ruby
     def render(context)
       MyTagRenderer.new(context).render
     end

     # Helper class to handle rendering logic
     class MyTagRenderer
       def initialize(context)
         @context = context
         @site = context.registers[:site]
       end

       def render
         # logic here
       end
     end
     ```

2. **Stateless Utilities (Modules):**
   - For utility modules, keep methods static (`def self.method`).
   - Break complex logic into private class methods named with a leading underscore.
   - **Pattern:**
     ```ruby
     def self.public_method(arg)
       _private_helper(arg)
     end

     def self._private_helper(arg)
       # logic
     end
     ```

3. **General Quality:**
   - Fix "bad code" or poor style even if RuboCop misses it (e.g., redundant logic, unclear variable names, deeply nested conditionals).
   - Ensure `# frozen_string_literal: true` is at the top.

INSTRUCTIONS:
1. Fix the specific RuboCop errors listed above.
2. Apply the Refactoring Patterns defined in the Style Guide.
3. Improve readability and maintainability generally.
4. **CRITICAL:** DO NOT change the external behavior or API of the code.
5. DO NOT remove comments unless they are the specific "rubocop:disable" comments causing issues.
6. Return the FULL content of the fixed file.

SOURCE CODE:
```ruby
# _tests/plugins/utils/test_plugin_logger_utils.rb
require_relative '../../test_helper'
require 'minitest/mock'

class TestPluginLoggerUtils < Minitest::Test
  def setup
    @page_mock = create_doc({ 'path' => 'path/page.html' }, '/page.html')
    # @silent_logger_stub is not needed here as we'll use Minitest::Mock for Jekyll.logger
  end

  # Helper to create a context with a site having specific logging configs
  def create_test_context(site_config_overrides = {})
    # Ensure default environment is 'test' unless overridden
    # And ensure a default plugin_log_level for predictability if not overridden
    full_config_overrides = {
      'environment' => 'test',
      'plugin_log_level' => PluginLoggerUtils::DEFAULT_SITE_CONSOLE_LEVEL_STRING
    }.merge(site_config_overrides)
    site = create_site(full_config_overrides)
    create_context({}, { site: site, page: @page_mock })
  end

  # Helper to strip ANSI escape codes
  def strip_ansi(str)
    str.gsub(/\e\[([;\d]+)?m/, '')
  end

  # --- Test Cases ---

  # --- Testing Tag Enable/Disable (Master Switch) ---
  def test_logging_disabled_for_tag_type_overrides_level
    # Site config: tag enabled=false, global level=debug
    # Message level: warn
    # Expected: No console, No HTML
    ctx = create_test_context({
                                'plugin_log_level' => 'debug', # Global level is permissive
                                'plugin_logging' => { 'MY_TAG' => false } # But this tag is OFF
                              })
    mock_logger = Minitest::Mock.new # Expect no calls

    html_output = ''
    # No need to capture_io if we expect no console output and mock_logger verifies no calls
    Jekyll.stub :logger, mock_logger do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Test', level: :warn)
    end
    assert_equal '', html_output, 'HTML output should be empty when tag logging is false'
    mock_logger.verify
  end

  # --- Testing Console Output Based on Global Level vs. Message Level ---
  def test_console_log_when_message_level_meets_global_threshold
    # Site config: tag enabled=true, global level=info
    # Message level: warn (warn > info, so should log)
    # Expected: Console log, HTML comment (if not prod)
    ctx = create_test_context({
                                'plugin_log_level' => 'info', # Global threshold
                                'plugin_logging' => { 'MY_TAG' => true }
                              })

    mock_logger = Minitest::Mock.new
    # Expected message now includes the level prefix
    expected_console_msg = "[WARN] MY_TAG_FAILURE: Reason='Test'  SourcePage='path/page.html'"
    mock_logger.expect(:warn, nil, ['PluginLiquid:', expected_console_msg])

    html_output = ''
    Jekyll.stub :logger, mock_logger do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Test', level: :warn)
    end

    mock_logger.verify
    assert_match %r{<!-- \[WARN\] MY_TAG_FAILURE: Reason='Test'\s*SourcePage='path/page\.html' -->}, html_output
  end

  def test_console_log_suppressed_when_message_level_below_global_threshold
    # Site config: tag enabled=true, global level=warn
    # Message level: info (info < warn, so should NOT log to console)
    # Expected: No console log, BUT HTML comment still generated (if not prod)
    ctx = create_test_context({
                                'plugin_log_level' => 'warn', # Global threshold
                                'plugin_logging' => { 'MY_TAG' => true }
                              })
    mock_logger = Minitest::Mock.new # Expect no calls to :info, :warn, etc.

    html_output = ''
    Jekyll.stub :logger, mock_logger do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Test', level: :info)
    end

    mock_logger.verify # Verifies no methods were called on the mock
    # HTML comment should still include the original message level
    assert_match %r{<!-- \[INFO\] MY_TAG_FAILURE: Reason='Test'\s*SourcePage='path/page\.html' -->}, html_output,
                 'HTML comment should still be generated'
  end

  def test_console_log_uses_default_global_level_if_not_set
    # Test with plugin_log_level not explicitly set in site_config_overrides,
    # so it should use PluginLoggerUtils::DEFAULT_SITE_CONSOLE_LEVEL_STRING ('warn').
    # Message level is :warn, so it should log.
    ctx = create_test_context({
                                'plugin_logging' => { 'MY_TAG' => true }
                                # 'plugin_log_level' is implicitly 'warn' due to create_test_context defaults merging with PluginLoggerUtils::DEFAULT_SITE_CONSOLE_LEVEL_STRING
                              })

    mock_logger = Minitest::Mock.new
    expected_console_msg = "[WARN] MY_TAG_FAILURE: Reason='Test'  SourcePage='path/page.html'"
    mock_logger.expect(:warn, nil, ['PluginLiquid:', expected_console_msg])

    Jekyll.stub :logger, mock_logger do
      PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Test', level: :warn)
    end
    mock_logger.verify
  end

  def test_console_log_uses_default_message_level_if_not_passed
    # Default message level is :warn (PluginLoggerUtils::DEFAULT_MESSAGE_LEVEL_SYMBOL)
    # Global console level is permissive ('debug')
    ctx = create_test_context({
                                'plugin_log_level' => 'debug', # Global console level is permissive
                                'plugin_logging' => { 'MY_TAG' => true }
                              })

    mock_logger = Minitest::Mock.new
    # Default message level is :warn
    expected_console_msg = "[WARN] MY_TAG_FAILURE: Reason='Test'  SourcePage='path/page.html'"
    mock_logger.expect(:warn, nil, ['PluginLiquid:', expected_console_msg])

    Jekyll.stub :logger, mock_logger do
      PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Test') # No level passed
    end
    mock_logger.verify
  end

  # --- Testing HTML Comment Generation ---
  def test_html_comment_in_non_production_when_enabled_and_level_met
    # Site config: tag enabled=true, global level=debug, env=test
    # Message level: debug
    # Expected: HTML comment
    ctx = create_test_context({
                                'environment' => 'test',
                                'plugin_log_level' => 'debug', # Console level
                                'plugin_logging' => { 'MY_TAG' => true }
                              })
    html_output = ''
    # Use a mock that responds to :debug for console output
    logger_responds_to_debug = Minitest::Mock.new
    logger_responds_to_debug.expect(:debug, nil, [String, String]) # Allow any two string args

    Jekyll.stub :logger, logger_responds_to_debug do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Debug Test',
                                                         level: :debug)
    end
    logger_responds_to_debug.verify # Ensure it was called (or not, if level filtering suppressed it)
    assert_match %r{<!-- \[DEBUG\] MY_TAG_FAILURE: Reason='Debug Test'\s*SourcePage='path/page\.html' -->}, html_output
  end

  def test_html_comment_in_non_production_even_if_console_suppressed_by_level
    # Site config: tag enabled=true, global level=error, env=test
    # Message level: warn (warn < error, so console suppressed)
    # Expected: HTML comment still generated
    ctx = create_test_context({
                                'environment' => 'test',
                                'plugin_log_level' => 'error', # Console only shows errors
                                'plugin_logging' => { 'MY_TAG' => true }
                              })
    html_output = ''
    # We expect no console output for a :warn message because global level is :error.
    # So, mock_logger should have no expectations for :warn.
    mock_logger_for_html_test = Minitest::Mock.new
    Jekyll.stub :logger, mock_logger_for_html_test do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Warn Test',
                                                         level: :warn)
    end
    mock_logger_for_html_test.verify # Verify no console methods were called
    assert_match %r{<!-- \[WARN\] MY_TAG_FAILURE: Reason='Warn Test'\s*SourcePage='path/page\.html' -->}, html_output
  end

  def test_no_html_comment_in_production_even_if_enabled_and_level_met
    # Site config: tag enabled=true, global level=debug, env=production
    # Message level: debug
    # Expected: NO HTML comment
    ctx = create_test_context({
                                'environment' => 'production',
                                'plugin_log_level' => 'debug',
                                'plugin_logging' => { 'MY_TAG' => true }
                              })
    html_output = ''
    # Console output should still happen if level is met
    logger_responds_to_debug = Minitest::Mock.new
    logger_responds_to_debug.expect(:debug, nil, [String, String])

    Jekyll.stub :logger, logger_responds_to_debug do
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Prod Test',
                                                         level: :debug)
    end
    logger_responds_to_debug.verify
    assert_equal '', html_output, 'HTML output should be empty in production'
  end

  def test_no_html_comment_if_tag_disabled
    # Site config: tag enabled=false, env=test
    # Expected: No HTML comment
    ctx = create_test_context({
                                'environment' => 'test',
                                'plugin_logging' => { 'MY_TAG' => false } # Logging for MY_TAG is off
                              })
    html_output = ''
    Jekyll.stub :logger, Minitest::Mock.new do # Stub to silence potential console output
      html_output = PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Disabled Test')
    end
    assert_equal '', html_output, 'HTML output should be empty when tag logging is disabled'
  end

  def test_puts_fallback_used_when_jekyll_logger_cannot_handle_level
    ctx = create_test_context({
                                'plugin_log_level' => 'debug', # Ensure console logging is attempted
                                'plugin_logging' => { 'MY_TAG' => true }
                              })
    simple_logger = Object.new

    stdout_str, = capture_io do
      Jekyll.stub :logger, simple_logger do
        PluginLoggerUtils.log_liquid_failure(context: ctx, tag_type: 'MY_TAG', reason: 'Puts Test', level: :warn)
      end
    end
    # Puts fallback now includes the level in its output string
    assert_match %r{\[PLUGIN_LIQUID_LOG\] \[WARN\] MY_TAG_FAILURE: Reason='Puts Test'\s*SourcePage='path/page\.html'},
                 stdout_str
  end

  # --- Test for internal logger error when context/site is bad ---
  # These tests verify the STDERR fallback when site.config is inaccessible.

  def test_internal_logger_error_if_context_is_nil
    _stdout_str, stderr_str = capture_io do
      # This call passes level: :error
      PluginLoggerUtils.log_liquid_failure(context: nil, tag_type: 'CTX_NIL', reason: 'Bad context', level: :error)
    end
    cleaned_stderr = strip_ansi(stderr_str).strip
    # Define the exact expected string after cleaning
    expected_text = 'PluginLogger: [PLUGIN LOGGER ERROR] Context, Site, or Site Config unavailable for logging. Original Call: CTX_NIL - error: Bad context'
    assert_equal expected_text, cleaned_stderr
  end

  def test_internal_logger_error_if_context_has_no_site
    context_no_site = create_context({}, {}) # No :site register
    _stdout_str, stderr_str = capture_io do
      PluginLoggerUtils.log_liquid_failure(context: context_no_site, tag_type: 'CTX_NO_SITE', reason: 'Bad context',
                                           level: :error)
    end
    cleaned_stderr = strip_ansi(stderr_str).strip
    # Define the exact expected string after cleaning
    expected_text = 'PluginLogger: [PLUGIN LOGGER ERROR] Context, Site, or Site Config unavailable for logging. Original Call: CTX_NO_SITE - error: Bad context'
    assert_equal expected_text, cleaned_stderr
  end
end
```
